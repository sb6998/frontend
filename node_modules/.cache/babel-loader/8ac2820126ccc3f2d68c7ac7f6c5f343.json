{"ast":null,"code":"const cookie = require('cookie');\n\nconst yargs = require('@curlconverter/yargs');\n\nconst URL = require('url');\n\nconst querystring = require('query-string');\n\nconst nunjucks = require('nunjucks');\n\nconst env = nunjucks.configure(['templates/'], {\n  // set folders with templates\n  autoescape: false\n});\nenv.addFilter('isArr', something => Array.isArray(something));\nenv.addFilter('isString', something => typeof something === 'string');\nenv.addFilter('isNumber', something => typeof something === 'number');\n\nconst parseCurlCommand = curlCommand => {\n  // Remove newlines (and from continuations)\n  curlCommand = curlCommand.replace(/\\\\\\r|\\\\\\n/g, ''); // Remove extra whitespace\n\n  curlCommand = curlCommand.replace(/\\s+/g, ' '); // yargs parses -XPOST as separate arguments. just prescreen for it.\n\n  curlCommand = curlCommand.replace(/ -XPOST/, ' -X POST');\n  curlCommand = curlCommand.replace(/ -XGET/, ' -X GET');\n  curlCommand = curlCommand.replace(/ -XPUT/, ' -X PUT');\n  curlCommand = curlCommand.replace(/ -XPATCH/, ' -X PATCH');\n  curlCommand = curlCommand.replace(/ -XDELETE/, ' -X DELETE'); // Safari adds `-Xnull` if is unable to determine the request type, it can be ignored\n\n  curlCommand = curlCommand.replace(/ -Xnull/, ' ');\n  curlCommand = curlCommand.trim(); // Parse with some understanding of the meanings of flags.  In particular,\n  // boolean flags can be trouble if the URL to fetch follows immediately\n  // after, since it will be taken as an argument to the flag rather than\n  // interpreted as a positional argument.  Someone should add all the flags\n  // likely to cause trouble here.\n\n  const parsedArguments = yargs.boolean(['I', 'head', 'compressed', 'L', 'k', 'silent', 's']).alias('H', 'header').alias('A', 'user-agent').parse(curlCommand);\n  let cookieString;\n  let cookies;\n  let url = parsedArguments._[1]; // if url argument wasn't where we expected it, try to find it in the other arguments\n\n  if (!url) {\n    for (const argName in parsedArguments) {\n      if (typeof parsedArguments[argName] === 'string') {\n        if (parsedArguments[argName].indexOf('http') === 0 || parsedArguments[argName].indexOf('www.') === 0) {\n          url = parsedArguments[argName];\n        }\n      }\n    }\n  }\n\n  let headers;\n\n  if (parsedArguments.header) {\n    if (!headers) {\n      headers = {};\n    }\n\n    if (!Array.isArray(parsedArguments.header)) {\n      parsedArguments.header = [parsedArguments.header];\n    }\n\n    parsedArguments.header.forEach(header => {\n      if (header.indexOf('Cookie') !== -1) {\n        cookieString = header;\n      } else {\n        const components = header.split(/:(.*)/);\n\n        if (components[1]) {\n          headers[components[0]] = components[1].trim();\n        }\n      }\n    });\n  }\n\n  if (parsedArguments['user-agent']) {\n    if (!headers) {\n      headers = {};\n    }\n\n    headers['User-Agent'] = parsedArguments['user-agent'];\n  }\n\n  if (parsedArguments.b) {\n    cookieString = parsedArguments.b;\n  }\n\n  if (parsedArguments.cookie) {\n    cookieString = parsedArguments.cookie;\n  }\n\n  let multipartUploads;\n\n  if (parsedArguments.F) {\n    multipartUploads = {};\n\n    if (!Array.isArray(parsedArguments.F)) {\n      parsedArguments.F = [parsedArguments.F];\n    }\n\n    parsedArguments.F.forEach(multipartArgument => {\n      // input looks like key=value. value could be json or a file path prepended with an @\n      const splitArguments = multipartArgument.split('=', 2);\n      const key = splitArguments[0];\n      const value = splitArguments[1];\n      multipartUploads[key] = value;\n    });\n  }\n\n  if (cookieString) {\n    const cookieParseOptions = {\n      decode: function (s) {\n        return s;\n      }\n    }; // separate out cookie headers into separate data structure\n    // note: cookie is case insensitive\n\n    cookies = cookie.parse(cookieString.replace(/^Cookie: /gi, ''), cookieParseOptions);\n  }\n\n  let method;\n\n  if (parsedArguments.X === 'POST') {\n    method = 'post';\n  } else if (parsedArguments.X === 'PUT' || parsedArguments.T) {\n    method = 'put';\n  } else if (parsedArguments.X === 'PATCH') {\n    method = 'patch';\n  } else if (parsedArguments.X === 'DELETE') {\n    method = 'delete';\n  } else if (parsedArguments.X === 'OPTIONS') {\n    method = 'options';\n  } else if ((parsedArguments.d || parsedArguments.data || parsedArguments['data-ascii'] || parsedArguments['data-binary'] || parsedArguments['data-raw'] || parsedArguments.F || parsedArguments.form) && !(parsedArguments.G || parsedArguments.get)) {\n    method = 'post';\n  } else if (parsedArguments.I || parsedArguments.head) {\n    method = 'head';\n  } else {\n    method = 'get';\n  }\n\n  const compressed = !!parsedArguments.compressed;\n  const urlObject = URL.parse(url); // eslint-disable-line\n  // if GET request with data, convert data to query string\n  // NB: the -G flag does not change the http verb. It just moves the data into the url.\n\n  if (parsedArguments.G || parsedArguments.get) {\n    urlObject.query = urlObject.query ? urlObject.query : '';\n    const option = 'd' in parsedArguments ? 'd' : 'data' in parsedArguments ? 'data' : null;\n\n    if (option) {\n      let urlQueryString = '';\n\n      if (url.indexOf('?') < 0) {\n        url += '?';\n      } else {\n        urlQueryString += '&';\n      }\n\n      if (typeof parsedArguments[option] === 'object') {\n        urlQueryString += parsedArguments[option].join('&');\n      } else {\n        urlQueryString += parsedArguments[option];\n      }\n\n      urlObject.query += urlQueryString;\n      url += urlQueryString;\n      delete parsedArguments[option];\n    }\n  }\n\n  if (urlObject.query && urlObject.query.endsWith('&')) {\n    urlObject.query = urlObject.query.slice(0, -1);\n  }\n\n  const query = querystring.parse(urlObject.query, {\n    sort: false\n  });\n\n  for (const param in query) {\n    if (query[param] === null) {\n      query[param] = '';\n    }\n  }\n\n  urlObject.search = null; // Clean out the search/query portion.\n\n  const request = {\n    url: url,\n    urlWithoutQuery: URL.format(urlObject)\n  };\n\n  if (compressed) {\n    request.compressed = true;\n  }\n\n  if (Object.keys(query).length > 0) {\n    request.query = query;\n  }\n\n  if (headers) {\n    request.headers = headers;\n  }\n\n  request.method = method;\n\n  if (cookies) {\n    request.cookies = cookies;\n    request.cookieString = cookieString.replace('Cookie: ', '');\n  }\n\n  if (multipartUploads) {\n    request.multipartUploads = multipartUploads;\n  }\n\n  if (parsedArguments.data) {\n    request.data = parsedArguments.data;\n  } else if (parsedArguments['data-binary']) {\n    request.data = parsedArguments['data-binary'];\n    request.isDataBinary = true;\n  } else if (parsedArguments.d) {\n    request.data = parsedArguments.d;\n  } else if (parsedArguments['data-ascii']) {\n    request.data = parsedArguments['data-ascii'];\n  } else if (parsedArguments['data-raw']) {\n    request.data = parsedArguments['data-raw'];\n    request.isDataRaw = true;\n  }\n\n  if (parsedArguments.u) {\n    request.auth = parsedArguments.u;\n  }\n\n  if (parsedArguments.user) {\n    request.auth = parsedArguments.user;\n  }\n\n  if (Array.isArray(request.data)) {\n    request.dataArray = request.data;\n    request.data = request.data.join('&');\n  }\n\n  if (parsedArguments.k || parsedArguments.insecure) {\n    request.insecure = true;\n  }\n\n  return request;\n};\n\nconst serializeCookies = cookieDict => {\n  let cookieString = '';\n  let i = 0;\n  const cookieCount = Object.keys(cookieDict).length;\n\n  for (const cookieName in cookieDict) {\n    const cookieValue = cookieDict[cookieName];\n    cookieString += cookieName + '=' + cookieValue;\n\n    if (i < cookieCount - 1) {\n      cookieString += '; ';\n    }\n\n    i++;\n  }\n\n  return cookieString;\n};\n\nmodule.exports = {\n  parseCurlCommand: parseCurlCommand,\n  serializeCookies: serializeCookies\n};","map":{"version":3,"sources":["/home/saurabh/Desktop/saarthi/frontend/node_modules/curlconverter/util.js"],"names":["cookie","require","yargs","URL","querystring","nunjucks","env","configure","autoescape","addFilter","something","Array","isArray","parseCurlCommand","curlCommand","replace","trim","parsedArguments","boolean","alias","parse","cookieString","cookies","url","_","argName","indexOf","headers","header","forEach","components","split","b","multipartUploads","F","multipartArgument","splitArguments","key","value","cookieParseOptions","decode","s","method","X","T","d","data","form","G","get","I","head","compressed","urlObject","query","option","urlQueryString","join","endsWith","slice","sort","param","search","request","urlWithoutQuery","format","Object","keys","length","isDataBinary","isDataRaw","u","auth","user","dataArray","k","insecure","serializeCookies","cookieDict","i","cookieCount","cookieName","cookieValue","module","exports"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,sBAAD,CAArB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,KAAD,CAAnB;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAxB;;AAEA,MAAMK,GAAG,GAAGD,QAAQ,CAACE,SAAT,CAAmB,CAAC,YAAD,CAAnB,EAAmC;AAAE;AAC/CC,EAAAA,UAAU,EAAE;AADiC,CAAnC,CAAZ;AAGAF,GAAG,CAACG,SAAJ,CAAc,OAAd,EAAuBC,SAAS,IAAIC,KAAK,CAACC,OAAN,CAAcF,SAAd,CAApC;AACAJ,GAAG,CAACG,SAAJ,CAAc,UAAd,EAA0BC,SAAS,IAAI,OAAOA,SAAP,KAAqB,QAA5D;AACAJ,GAAG,CAACG,SAAJ,CAAc,UAAd,EAA0BC,SAAS,IAAI,OAAOA,SAAP,KAAqB,QAA5D;;AAEA,MAAMG,gBAAgB,GAAGC,WAAW,IAAI;AACtC;AACAA,EAAAA,WAAW,GAAGA,WAAW,CAACC,OAAZ,CAAoB,YAApB,EAAkC,EAAlC,CAAd,CAFsC,CAItC;;AACAD,EAAAA,WAAW,GAAGA,WAAW,CAACC,OAAZ,CAAoB,MAApB,EAA4B,GAA5B,CAAd,CALsC,CAOtC;;AACAD,EAAAA,WAAW,GAAGA,WAAW,CAACC,OAAZ,CAAoB,SAApB,EAA+B,UAA/B,CAAd;AACAD,EAAAA,WAAW,GAAGA,WAAW,CAACC,OAAZ,CAAoB,QAApB,EAA8B,SAA9B,CAAd;AACAD,EAAAA,WAAW,GAAGA,WAAW,CAACC,OAAZ,CAAoB,QAApB,EAA8B,SAA9B,CAAd;AACAD,EAAAA,WAAW,GAAGA,WAAW,CAACC,OAAZ,CAAoB,UAApB,EAAgC,WAAhC,CAAd;AACAD,EAAAA,WAAW,GAAGA,WAAW,CAACC,OAAZ,CAAoB,WAApB,EAAiC,YAAjC,CAAd,CAZsC,CAatC;;AACAD,EAAAA,WAAW,GAAGA,WAAW,CAACC,OAAZ,CAAoB,SAApB,EAA+B,GAA/B,CAAd;AACAD,EAAAA,WAAW,GAAGA,WAAW,CAACE,IAAZ,EAAd,CAfsC,CAiBtC;AACA;AACA;AACA;AACA;;AACA,QAAMC,eAAe,GAAGf,KAAK,CAC1BgB,OADqB,CACb,CAAC,GAAD,EAAM,MAAN,EAAc,YAAd,EAA4B,GAA5B,EAAiC,GAAjC,EAAsC,QAAtC,EAAgD,GAAhD,CADa,EAErBC,KAFqB,CAEf,GAFe,EAEV,QAFU,EAGrBA,KAHqB,CAGf,GAHe,EAGV,YAHU,EAIrBC,KAJqB,CAIfN,WAJe,CAAxB;AAMA,MAAIO,YAAJ;AACA,MAAIC,OAAJ;AACA,MAAIC,GAAG,GAAGN,eAAe,CAACO,CAAhB,CAAkB,CAAlB,CAAV,CA9BsC,CAgCtC;;AACA,MAAI,CAACD,GAAL,EAAU;AACR,SAAK,MAAME,OAAX,IAAsBR,eAAtB,EAAuC;AACrC,UAAI,OAAOA,eAAe,CAACQ,OAAD,CAAtB,KAAoC,QAAxC,EAAkD;AAChD,YAAIR,eAAe,CAACQ,OAAD,CAAf,CAAyBC,OAAzB,CAAiC,MAAjC,MAA6C,CAA7C,IAAkDT,eAAe,CAACQ,OAAD,CAAf,CAAyBC,OAAzB,CAAiC,MAAjC,MAA6C,CAAnG,EAAsG;AACpGH,UAAAA,GAAG,GAAGN,eAAe,CAACQ,OAAD,CAArB;AACD;AACF;AACF;AACF;;AAED,MAAIE,OAAJ;;AAEA,MAAIV,eAAe,CAACW,MAApB,EAA4B;AAC1B,QAAI,CAACD,OAAL,EAAc;AACZA,MAAAA,OAAO,GAAG,EAAV;AACD;;AACD,QAAI,CAAChB,KAAK,CAACC,OAAN,CAAcK,eAAe,CAACW,MAA9B,CAAL,EAA4C;AAC1CX,MAAAA,eAAe,CAACW,MAAhB,GAAyB,CAACX,eAAe,CAACW,MAAjB,CAAzB;AACD;;AACDX,IAAAA,eAAe,CAACW,MAAhB,CAAuBC,OAAvB,CAA+BD,MAAM,IAAI;AACvC,UAAIA,MAAM,CAACF,OAAP,CAAe,QAAf,MAA6B,CAAC,CAAlC,EAAqC;AACnCL,QAAAA,YAAY,GAAGO,MAAf;AACD,OAFD,MAEO;AACL,cAAME,UAAU,GAAGF,MAAM,CAACG,KAAP,CAAa,OAAb,CAAnB;;AACA,YAAID,UAAU,CAAC,CAAD,CAAd,EAAmB;AACjBH,UAAAA,OAAO,CAACG,UAAU,CAAC,CAAD,CAAX,CAAP,GAAyBA,UAAU,CAAC,CAAD,CAAV,CAAcd,IAAd,EAAzB;AACD;AACF;AACF,KATD;AAUD;;AAED,MAAIC,eAAe,CAAC,YAAD,CAAnB,EAAmC;AACjC,QAAI,CAACU,OAAL,EAAc;AACZA,MAAAA,OAAO,GAAG,EAAV;AACD;;AACDA,IAAAA,OAAO,CAAC,YAAD,CAAP,GAAwBV,eAAe,CAAC,YAAD,CAAvC;AACD;;AAED,MAAIA,eAAe,CAACe,CAApB,EAAuB;AACrBX,IAAAA,YAAY,GAAGJ,eAAe,CAACe,CAA/B;AACD;;AACD,MAAIf,eAAe,CAACjB,MAApB,EAA4B;AAC1BqB,IAAAA,YAAY,GAAGJ,eAAe,CAACjB,MAA/B;AACD;;AACD,MAAIiC,gBAAJ;;AACA,MAAIhB,eAAe,CAACiB,CAApB,EAAuB;AACrBD,IAAAA,gBAAgB,GAAG,EAAnB;;AACA,QAAI,CAACtB,KAAK,CAACC,OAAN,CAAcK,eAAe,CAACiB,CAA9B,CAAL,EAAuC;AACrCjB,MAAAA,eAAe,CAACiB,CAAhB,GAAoB,CAACjB,eAAe,CAACiB,CAAjB,CAApB;AACD;;AACDjB,IAAAA,eAAe,CAACiB,CAAhB,CAAkBL,OAAlB,CAA0BM,iBAAiB,IAAI;AAC7C;AACA,YAAMC,cAAc,GAAGD,iBAAiB,CAACJ,KAAlB,CAAwB,GAAxB,EAA6B,CAA7B,CAAvB;AACA,YAAMM,GAAG,GAAGD,cAAc,CAAC,CAAD,CAA1B;AACA,YAAME,KAAK,GAAGF,cAAc,CAAC,CAAD,CAA5B;AACAH,MAAAA,gBAAgB,CAACI,GAAD,CAAhB,GAAwBC,KAAxB;AACD,KAND;AAOD;;AACD,MAAIjB,YAAJ,EAAkB;AAChB,UAAMkB,kBAAkB,GAAG;AACzBC,MAAAA,MAAM,EAAE,UAAUC,CAAV,EAAa;AAAE,eAAOA,CAAP;AAAU;AADR,KAA3B,CADgB,CAIhB;AACA;;AACAnB,IAAAA,OAAO,GAAGtB,MAAM,CAACoB,KAAP,CAAaC,YAAY,CAACN,OAAb,CAAqB,aAArB,EAAoC,EAApC,CAAb,EAAsDwB,kBAAtD,CAAV;AACD;;AACD,MAAIG,MAAJ;;AACA,MAAIzB,eAAe,CAAC0B,CAAhB,KAAsB,MAA1B,EAAkC;AAChCD,IAAAA,MAAM,GAAG,MAAT;AACD,GAFD,MAEO,IAAIzB,eAAe,CAAC0B,CAAhB,KAAsB,KAAtB,IACT1B,eAAe,CAAC2B,CADX,EACc;AACnBF,IAAAA,MAAM,GAAG,KAAT;AACD,GAHM,MAGA,IAAIzB,eAAe,CAAC0B,CAAhB,KAAsB,OAA1B,EAAmC;AACxCD,IAAAA,MAAM,GAAG,OAAT;AACD,GAFM,MAEA,IAAIzB,eAAe,CAAC0B,CAAhB,KAAsB,QAA1B,EAAoC;AACzCD,IAAAA,MAAM,GAAG,QAAT;AACD,GAFM,MAEA,IAAIzB,eAAe,CAAC0B,CAAhB,KAAsB,SAA1B,EAAqC;AAC1CD,IAAAA,MAAM,GAAG,SAAT;AACD,GAFM,MAEA,IAAI,CAACzB,eAAe,CAAC4B,CAAhB,IACV5B,eAAe,CAAC6B,IADN,IAEV7B,eAAe,CAAC,YAAD,CAFL,IAGVA,eAAe,CAAC,aAAD,CAHL,IAIVA,eAAe,CAAC,UAAD,CAJL,IAKVA,eAAe,CAACiB,CALN,IAMVjB,eAAe,CAAC8B,IANP,KAMgB,EAAG9B,eAAe,CAAC+B,CAAhB,IAAqB/B,eAAe,CAACgC,GAAxC,CANpB,EAMmE;AACxEP,IAAAA,MAAM,GAAG,MAAT;AACD,GARM,MAQA,IAAIzB,eAAe,CAACiC,CAAhB,IACTjC,eAAe,CAACkC,IADX,EACiB;AACtBT,IAAAA,MAAM,GAAG,MAAT;AACD,GAHM,MAGA;AACLA,IAAAA,MAAM,GAAG,KAAT;AACD;;AAED,QAAMU,UAAU,GAAG,CAAC,CAACnC,eAAe,CAACmC,UAArC;AACA,QAAMC,SAAS,GAAGlD,GAAG,CAACiB,KAAJ,CAAUG,GAAV,CAAlB,CA/HsC,CA+HL;AAEjC;AACA;;AACA,MAAIN,eAAe,CAAC+B,CAAhB,IAAqB/B,eAAe,CAACgC,GAAzC,EAA8C;AAC5CI,IAAAA,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACC,KAA5B,GAAoC,EAAtD;AACA,UAAMC,MAAM,GAAG,OAAOtC,eAAP,GAAyB,GAAzB,GAA+B,UAAUA,eAAV,GAA4B,MAA5B,GAAqC,IAAnF;;AACA,QAAIsC,MAAJ,EAAY;AACV,UAAIC,cAAc,GAAG,EAArB;;AAEA,UAAIjC,GAAG,CAACG,OAAJ,CAAY,GAAZ,IAAmB,CAAvB,EAA0B;AACxBH,QAAAA,GAAG,IAAI,GAAP;AACD,OAFD,MAEO;AACLiC,QAAAA,cAAc,IAAI,GAAlB;AACD;;AAED,UAAI,OAAQvC,eAAe,CAACsC,MAAD,CAAvB,KAAqC,QAAzC,EAAmD;AACjDC,QAAAA,cAAc,IAAIvC,eAAe,CAACsC,MAAD,CAAf,CAAwBE,IAAxB,CAA6B,GAA7B,CAAlB;AACD,OAFD,MAEO;AACLD,QAAAA,cAAc,IAAIvC,eAAe,CAACsC,MAAD,CAAjC;AACD;;AACDF,MAAAA,SAAS,CAACC,KAAV,IAAmBE,cAAnB;AACAjC,MAAAA,GAAG,IAAIiC,cAAP;AACA,aAAOvC,eAAe,CAACsC,MAAD,CAAtB;AACD;AACF;;AACD,MAAIF,SAAS,CAACC,KAAV,IAAmBD,SAAS,CAACC,KAAV,CAAgBI,QAAhB,CAAyB,GAAzB,CAAvB,EAAsD;AACpDL,IAAAA,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACC,KAAV,CAAgBK,KAAhB,CAAsB,CAAtB,EAAyB,CAAC,CAA1B,CAAlB;AACD;;AACD,QAAML,KAAK,GAAGlD,WAAW,CAACgB,KAAZ,CAAkBiC,SAAS,CAACC,KAA5B,EAAmC;AAAEM,IAAAA,IAAI,EAAE;AAAR,GAAnC,CAAd;;AACA,OAAK,MAAMC,KAAX,IAAoBP,KAApB,EAA2B;AACzB,QAAIA,KAAK,CAACO,KAAD,CAAL,KAAiB,IAArB,EAA2B;AACzBP,MAAAA,KAAK,CAACO,KAAD,CAAL,GAAe,EAAf;AACD;AACF;;AAEDR,EAAAA,SAAS,CAACS,MAAV,GAAmB,IAAnB,CAnKsC,CAmKd;;AACxB,QAAMC,OAAO,GAAG;AACdxC,IAAAA,GAAG,EAAEA,GADS;AAEdyC,IAAAA,eAAe,EAAE7D,GAAG,CAAC8D,MAAJ,CAAWZ,SAAX;AAFH,GAAhB;;AAIA,MAAID,UAAJ,EAAgB;AACdW,IAAAA,OAAO,CAACX,UAAR,GAAqB,IAArB;AACD;;AAED,MAAIc,MAAM,CAACC,IAAP,CAAYb,KAAZ,EAAmBc,MAAnB,GAA4B,CAAhC,EAAmC;AACjCL,IAAAA,OAAO,CAACT,KAAR,GAAgBA,KAAhB;AACD;;AACD,MAAI3B,OAAJ,EAAa;AACXoC,IAAAA,OAAO,CAACpC,OAAR,GAAkBA,OAAlB;AACD;;AACDoC,EAAAA,OAAO,CAACrB,MAAR,GAAiBA,MAAjB;;AAEA,MAAIpB,OAAJ,EAAa;AACXyC,IAAAA,OAAO,CAACzC,OAAR,GAAkBA,OAAlB;AACAyC,IAAAA,OAAO,CAAC1C,YAAR,GAAuBA,YAAY,CAACN,OAAb,CAAqB,UAArB,EAAiC,EAAjC,CAAvB;AACD;;AACD,MAAIkB,gBAAJ,EAAsB;AACpB8B,IAAAA,OAAO,CAAC9B,gBAAR,GAA2BA,gBAA3B;AACD;;AACD,MAAIhB,eAAe,CAAC6B,IAApB,EAA0B;AACxBiB,IAAAA,OAAO,CAACjB,IAAR,GAAe7B,eAAe,CAAC6B,IAA/B;AACD,GAFD,MAEO,IAAI7B,eAAe,CAAC,aAAD,CAAnB,EAAoC;AACzC8C,IAAAA,OAAO,CAACjB,IAAR,GAAe7B,eAAe,CAAC,aAAD,CAA9B;AACA8C,IAAAA,OAAO,CAACM,YAAR,GAAuB,IAAvB;AACD,GAHM,MAGA,IAAIpD,eAAe,CAAC4B,CAApB,EAAuB;AAC5BkB,IAAAA,OAAO,CAACjB,IAAR,GAAe7B,eAAe,CAAC4B,CAA/B;AACD,GAFM,MAEA,IAAI5B,eAAe,CAAC,YAAD,CAAnB,EAAmC;AACxC8C,IAAAA,OAAO,CAACjB,IAAR,GAAe7B,eAAe,CAAC,YAAD,CAA9B;AACD,GAFM,MAEA,IAAIA,eAAe,CAAC,UAAD,CAAnB,EAAiC;AACtC8C,IAAAA,OAAO,CAACjB,IAAR,GAAe7B,eAAe,CAAC,UAAD,CAA9B;AACA8C,IAAAA,OAAO,CAACO,SAAR,GAAoB,IAApB;AACD;;AAED,MAAIrD,eAAe,CAACsD,CAApB,EAAuB;AACrBR,IAAAA,OAAO,CAACS,IAAR,GAAevD,eAAe,CAACsD,CAA/B;AACD;;AACD,MAAItD,eAAe,CAACwD,IAApB,EAA0B;AACxBV,IAAAA,OAAO,CAACS,IAAR,GAAevD,eAAe,CAACwD,IAA/B;AACD;;AACD,MAAI9D,KAAK,CAACC,OAAN,CAAcmD,OAAO,CAACjB,IAAtB,CAAJ,EAAiC;AAC/BiB,IAAAA,OAAO,CAACW,SAAR,GAAoBX,OAAO,CAACjB,IAA5B;AACAiB,IAAAA,OAAO,CAACjB,IAAR,GAAeiB,OAAO,CAACjB,IAAR,CAAaW,IAAb,CAAkB,GAAlB,CAAf;AACD;;AAED,MAAIxC,eAAe,CAAC0D,CAAhB,IAAqB1D,eAAe,CAAC2D,QAAzC,EAAmD;AACjDb,IAAAA,OAAO,CAACa,QAAR,GAAmB,IAAnB;AACD;;AACD,SAAOb,OAAP;AACD,CAxND;;AA0NA,MAAMc,gBAAgB,GAAGC,UAAU,IAAI;AACrC,MAAIzD,YAAY,GAAG,EAAnB;AACA,MAAI0D,CAAC,GAAG,CAAR;AACA,QAAMC,WAAW,GAAGd,MAAM,CAACC,IAAP,CAAYW,UAAZ,EAAwBV,MAA5C;;AACA,OAAK,MAAMa,UAAX,IAAyBH,UAAzB,EAAqC;AACnC,UAAMI,WAAW,GAAGJ,UAAU,CAACG,UAAD,CAA9B;AACA5D,IAAAA,YAAY,IAAI4D,UAAU,GAAG,GAAb,GAAmBC,WAAnC;;AACA,QAAIH,CAAC,GAAGC,WAAW,GAAG,CAAtB,EAAyB;AACvB3D,MAAAA,YAAY,IAAI,IAAhB;AACD;;AACD0D,IAAAA,CAAC;AACF;;AACD,SAAO1D,YAAP;AACD,CAbD;;AAeA8D,MAAM,CAACC,OAAP,GAAiB;AACfvE,EAAAA,gBAAgB,EAAEA,gBADH;AAEfgE,EAAAA,gBAAgB,EAAEA;AAFH,CAAjB","sourcesContent":["const cookie = require('cookie')\nconst yargs = require('@curlconverter/yargs')\nconst URL = require('url')\nconst querystring = require('query-string')\nconst nunjucks = require('nunjucks')\n\nconst env = nunjucks.configure(['templates/'], { // set folders with templates\n  autoescape: false\n})\nenv.addFilter('isArr', something => Array.isArray(something))\nenv.addFilter('isString', something => typeof something === 'string')\nenv.addFilter('isNumber', something => typeof something === 'number')\n\nconst parseCurlCommand = curlCommand => {\n  // Remove newlines (and from continuations)\n  curlCommand = curlCommand.replace(/\\\\\\r|\\\\\\n/g, '')\n\n  // Remove extra whitespace\n  curlCommand = curlCommand.replace(/\\s+/g, ' ')\n\n  // yargs parses -XPOST as separate arguments. just prescreen for it.\n  curlCommand = curlCommand.replace(/ -XPOST/, ' -X POST')\n  curlCommand = curlCommand.replace(/ -XGET/, ' -X GET')\n  curlCommand = curlCommand.replace(/ -XPUT/, ' -X PUT')\n  curlCommand = curlCommand.replace(/ -XPATCH/, ' -X PATCH')\n  curlCommand = curlCommand.replace(/ -XDELETE/, ' -X DELETE')\n  // Safari adds `-Xnull` if is unable to determine the request type, it can be ignored\n  curlCommand = curlCommand.replace(/ -Xnull/, ' ')\n  curlCommand = curlCommand.trim()\n\n  // Parse with some understanding of the meanings of flags.  In particular,\n  // boolean flags can be trouble if the URL to fetch follows immediately\n  // after, since it will be taken as an argument to the flag rather than\n  // interpreted as a positional argument.  Someone should add all the flags\n  // likely to cause trouble here.\n  const parsedArguments = yargs\n    .boolean(['I', 'head', 'compressed', 'L', 'k', 'silent', 's'])\n    .alias('H', 'header')\n    .alias('A', 'user-agent')\n    .parse(curlCommand)\n\n  let cookieString\n  let cookies\n  let url = parsedArguments._[1]\n\n  // if url argument wasn't where we expected it, try to find it in the other arguments\n  if (!url) {\n    for (const argName in parsedArguments) {\n      if (typeof parsedArguments[argName] === 'string') {\n        if (parsedArguments[argName].indexOf('http') === 0 || parsedArguments[argName].indexOf('www.') === 0) {\n          url = parsedArguments[argName]\n        }\n      }\n    }\n  }\n\n  let headers\n\n  if (parsedArguments.header) {\n    if (!headers) {\n      headers = {}\n    }\n    if (!Array.isArray(parsedArguments.header)) {\n      parsedArguments.header = [parsedArguments.header]\n    }\n    parsedArguments.header.forEach(header => {\n      if (header.indexOf('Cookie') !== -1) {\n        cookieString = header\n      } else {\n        const components = header.split(/:(.*)/)\n        if (components[1]) {\n          headers[components[0]] = components[1].trim()\n        }\n      }\n    })\n  }\n\n  if (parsedArguments['user-agent']) {\n    if (!headers) {\n      headers = {}\n    }\n    headers['User-Agent'] = parsedArguments['user-agent']\n  }\n\n  if (parsedArguments.b) {\n    cookieString = parsedArguments.b\n  }\n  if (parsedArguments.cookie) {\n    cookieString = parsedArguments.cookie\n  }\n  let multipartUploads\n  if (parsedArguments.F) {\n    multipartUploads = {}\n    if (!Array.isArray(parsedArguments.F)) {\n      parsedArguments.F = [parsedArguments.F]\n    }\n    parsedArguments.F.forEach(multipartArgument => {\n      // input looks like key=value. value could be json or a file path prepended with an @\n      const splitArguments = multipartArgument.split('=', 2)\n      const key = splitArguments[0]\n      const value = splitArguments[1]\n      multipartUploads[key] = value\n    })\n  }\n  if (cookieString) {\n    const cookieParseOptions = {\n      decode: function (s) { return s }\n    }\n    // separate out cookie headers into separate data structure\n    // note: cookie is case insensitive\n    cookies = cookie.parse(cookieString.replace(/^Cookie: /gi, ''), cookieParseOptions)\n  }\n  let method\n  if (parsedArguments.X === 'POST') {\n    method = 'post'\n  } else if (parsedArguments.X === 'PUT' ||\n    parsedArguments.T) {\n    method = 'put'\n  } else if (parsedArguments.X === 'PATCH') {\n    method = 'patch'\n  } else if (parsedArguments.X === 'DELETE') {\n    method = 'delete'\n  } else if (parsedArguments.X === 'OPTIONS') {\n    method = 'options'\n  } else if ((parsedArguments.d ||\n    parsedArguments.data ||\n    parsedArguments['data-ascii'] ||\n    parsedArguments['data-binary'] ||\n    parsedArguments['data-raw'] ||\n    parsedArguments.F ||\n    parsedArguments.form) && !((parsedArguments.G || parsedArguments.get))) {\n    method = 'post'\n  } else if (parsedArguments.I ||\n    parsedArguments.head) {\n    method = 'head'\n  } else {\n    method = 'get'\n  }\n\n  const compressed = !!parsedArguments.compressed\n  const urlObject = URL.parse(url) // eslint-disable-line\n\n  // if GET request with data, convert data to query string\n  // NB: the -G flag does not change the http verb. It just moves the data into the url.\n  if (parsedArguments.G || parsedArguments.get) {\n    urlObject.query = urlObject.query ? urlObject.query : ''\n    const option = 'd' in parsedArguments ? 'd' : 'data' in parsedArguments ? 'data' : null\n    if (option) {\n      let urlQueryString = ''\n\n      if (url.indexOf('?') < 0) {\n        url += '?'\n      } else {\n        urlQueryString += '&'\n      }\n\n      if (typeof (parsedArguments[option]) === 'object') {\n        urlQueryString += parsedArguments[option].join('&')\n      } else {\n        urlQueryString += parsedArguments[option]\n      }\n      urlObject.query += urlQueryString\n      url += urlQueryString\n      delete parsedArguments[option]\n    }\n  }\n  if (urlObject.query && urlObject.query.endsWith('&')) {\n    urlObject.query = urlObject.query.slice(0, -1)\n  }\n  const query = querystring.parse(urlObject.query, { sort: false })\n  for (const param in query) {\n    if (query[param] === null) {\n      query[param] = ''\n    }\n  }\n\n  urlObject.search = null // Clean out the search/query portion.\n  const request = {\n    url: url,\n    urlWithoutQuery: URL.format(urlObject)\n  }\n  if (compressed) {\n    request.compressed = true\n  }\n\n  if (Object.keys(query).length > 0) {\n    request.query = query\n  }\n  if (headers) {\n    request.headers = headers\n  }\n  request.method = method\n\n  if (cookies) {\n    request.cookies = cookies\n    request.cookieString = cookieString.replace('Cookie: ', '')\n  }\n  if (multipartUploads) {\n    request.multipartUploads = multipartUploads\n  }\n  if (parsedArguments.data) {\n    request.data = parsedArguments.data\n  } else if (parsedArguments['data-binary']) {\n    request.data = parsedArguments['data-binary']\n    request.isDataBinary = true\n  } else if (parsedArguments.d) {\n    request.data = parsedArguments.d\n  } else if (parsedArguments['data-ascii']) {\n    request.data = parsedArguments['data-ascii']\n  } else if (parsedArguments['data-raw']) {\n    request.data = parsedArguments['data-raw']\n    request.isDataRaw = true\n  }\n\n  if (parsedArguments.u) {\n    request.auth = parsedArguments.u\n  }\n  if (parsedArguments.user) {\n    request.auth = parsedArguments.user\n  }\n  if (Array.isArray(request.data)) {\n    request.dataArray = request.data\n    request.data = request.data.join('&')\n  }\n\n  if (parsedArguments.k || parsedArguments.insecure) {\n    request.insecure = true\n  }\n  return request\n}\n\nconst serializeCookies = cookieDict => {\n  let cookieString = ''\n  let i = 0\n  const cookieCount = Object.keys(cookieDict).length\n  for (const cookieName in cookieDict) {\n    const cookieValue = cookieDict[cookieName]\n    cookieString += cookieName + '=' + cookieValue\n    if (i < cookieCount - 1) {\n      cookieString += '; '\n    }\n    i++\n  }\n  return cookieString\n}\n\nmodule.exports = {\n  parseCurlCommand: parseCurlCommand,\n  serializeCookies: serializeCookies\n}\n"]},"metadata":{},"sourceType":"script"}