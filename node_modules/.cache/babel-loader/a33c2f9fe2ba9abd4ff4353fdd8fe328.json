{"ast":null,"code":"// Author: Bob Rudis (bob@rud.is)\nconst util = require('../util');\n\nconst jsesc = require('jsesc');\n\nconst querystring = require('query-string');\n\nrequire('string.prototype.startswith');\n\nfunction reprn(value) {\n  // back-tick quote names\n  if (!value) {\n    return '``';\n  } else {\n    return '`' + value + '`';\n  }\n}\n\nfunction repr(value) {\n  // In context of url parameters, don't accept nulls and such.\n  if (!value) {\n    return \"''\";\n  } else {\n    return \"'\" + jsesc(value, {\n      quotes: 'single'\n    }) + \"'\";\n  }\n}\n\nfunction getQueryDict(request) {\n  let queryDict = 'params = list(\\n';\n  queryDict += Object.keys(request.query).map(paramName => {\n    const rawValue = request.query[paramName];\n    let paramValue;\n\n    if (Array.isArray(rawValue)) {\n      paramValue = 'c(' + rawValue.map(repr).join(', ') + ')';\n    } else {\n      paramValue = repr(rawValue);\n    }\n\n    return '  ' + reprn(paramName) + ' = ' + paramValue;\n  }).join(',\\n');\n  queryDict += '\\n)\\n';\n  return queryDict;\n}\n\nfunction getDataString(request) {\n  if (typeof request.data === 'number') {\n    request.data = request.data.toString();\n  }\n\n  if (!request.isDataRaw && request.data.startsWith('@')) {\n    const filePath = request.data.slice(1);\n    return 'data = upload_file(\\'' + filePath + '\\')';\n  }\n\n  const parsedQueryString = querystring.parse(request.data, {\n    sort: false\n  });\n  const keyCount = Object.keys(parsedQueryString).length;\n  const singleKeyOnly = keyCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]];\n  const singularData = request.isDataBinary || singleKeyOnly;\n\n  if (singularData) {\n    return 'data = ' + repr(request.data) + '\\n';\n  } else {\n    return getMultipleDataString(request, parsedQueryString);\n  }\n}\n\nfunction getMultipleDataString(request, parsedQueryString) {\n  let repeatedKey = false;\n\n  for (const key in parsedQueryString) {\n    const value = parsedQueryString[key];\n\n    if (Array.isArray(value)) {\n      repeatedKey = true;\n    }\n  }\n\n  let dataString;\n\n  if (repeatedKey) {\n    const els = [];\n    dataString = 'data = list(\\n';\n\n    for (const key in parsedQueryString) {\n      const value = parsedQueryString[key];\n\n      if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n          els.push('  ' + reprn(key) + ' = ' + repr(value[i]));\n        }\n      } else {\n        els.push('  ' + reprn(key) + ' = ' + repr(value));\n      }\n    }\n\n    dataString += els.join(',\\n');\n    dataString += '\\n)\\n';\n  } else {\n    dataString = 'data = list(\\n';\n    dataString += Object.keys(parsedQueryString).map(key => {\n      const value = parsedQueryString[key];\n      return '  ' + reprn(key) + ' = ' + repr(value);\n    }).join(',\\n');\n    dataString += '\\n)\\n';\n  }\n\n  return dataString;\n}\n\nfunction getFilesString(request) {\n  // http://docs.rstats-requests.org/en/master/user/quickstart/#post-a-multipart-encoded-file\n  let filesString = 'files = list(\\n';\n  filesString += Object.keys(request.multipartUploads).map(multipartKey => {\n    const multipartValue = request.multipartUploads[multipartKey];\n    let fileParam;\n\n    if (multipartValue.startsWith('@')) {\n      const fileName = multipartValue.slice(1); // filesString += '    ' + reprn(multipartKey) + ' (' + repr(fileName) + ', upload_file(' + repr(fileName) + '))'\n\n      fileParam = '  ' + reprn(multipartKey) + ' = upload_file(' + repr(fileName) + ')';\n    } else {\n      fileParam = '  ' + reprn(multipartKey) + ' = ' + repr(multipartValue) + '';\n    }\n\n    return fileParam;\n  }).join(',\\n');\n  filesString += '\\n)\\n';\n  return filesString;\n}\n\nconst torstats = curlCommand => {\n  const request = util.parseCurlCommand(curlCommand);\n  let cookieDict;\n\n  if (request.cookies) {\n    cookieDict = 'cookies = c(\\n';\n    cookieDict += Object.keys(request.cookies).map(cookieName => '  ' + repr(cookieName) + ' = ' + repr(request.cookies[cookieName])).join(',\\n');\n    cookieDict += '\\n)\\n';\n  }\n\n  let headerDict;\n\n  if (request.headers) {\n    const hels = [];\n    headerDict = 'headers = c(\\n';\n\n    for (const headerName in request.headers) {\n      hels.push('  ' + reprn(headerName) + ' = ' + repr(request.headers[headerName]));\n    }\n\n    headerDict += hels.join(',\\n');\n    headerDict += '\\n)\\n';\n  }\n\n  let queryDict;\n\n  if (request.query) {\n    queryDict = getQueryDict(request);\n  }\n\n  let dataString;\n  let filesString;\n\n  if (typeof request.data === 'string' || typeof request.data === 'number') {\n    dataString = getDataString(request);\n  } else if (request.multipartUploads) {\n    filesString = getFilesString(request);\n  } // curl automatically prepends 'http' if the scheme is missing, but rstats fails and returns an error\n  // we tack it on here to mimic curl\n\n\n  if (!request.url.match(/https?:/)) {\n    request.url = 'http://' + request.url;\n  }\n\n  if (!request.urlWithoutQuery.match(/https?:/)) {\n    request.urlWithoutQuery = 'http://' + request.urlWithoutQuery;\n  }\n\n  let requestLineWithUrlParams = 'res <- httr::' + request.method.toUpperCase() + '(url = \\'' + request.urlWithoutQuery + '\\'';\n  let requestLineWithOriginalUrl = 'res <- httr::' + request.method.toUpperCase() + '(url = \\'' + request.url + '\\'';\n  let requestLineBody = '';\n\n  if (request.headers) {\n    requestLineBody += ', httr::add_headers(.headers=headers)';\n  }\n\n  if (request.query) {\n    requestLineBody += ', query = params';\n  }\n\n  if (request.cookies) {\n    requestLineBody += ', httr::set_cookies(.cookies = cookies)';\n  }\n\n  if (typeof request.data === 'string') {\n    requestLineBody += ', body = data';\n  } else if (request.multipartUploads) {\n    requestLineBody += ', body = files';\n  }\n\n  if (request.insecure) {\n    requestLineBody += ', config = httr::config(ssl_verifypeer = FALSE)';\n  }\n\n  if (request.auth) {\n    const splitAuth = request.auth.split(':');\n    const user = splitAuth[0] || '';\n    const password = splitAuth[1] || '';\n    requestLineBody += ', httr::authenticate(' + repr(user) + ', ' + repr(password) + ')';\n  }\n\n  requestLineBody += ')';\n  requestLineWithOriginalUrl += requestLineBody.replace(', query = params', '');\n  requestLineWithUrlParams += requestLineBody;\n  let rstatsCode = '';\n  rstatsCode += 'require(httr)\\n\\n';\n\n  if (cookieDict) {\n    rstatsCode += cookieDict + '\\n';\n  }\n\n  if (headerDict) {\n    rstatsCode += headerDict + '\\n';\n  }\n\n  if (queryDict) {\n    rstatsCode += queryDict + '\\n';\n  }\n\n  if (dataString) {\n    rstatsCode += dataString + '\\n';\n  } else if (filesString) {\n    rstatsCode += filesString + '\\n';\n  }\n\n  rstatsCode += requestLineWithUrlParams;\n\n  if (request.query) {\n    rstatsCode += '\\n\\n' + '#NB. Original query string below. It seems impossible to parse and\\n' + '#reproduce query strings 100% accurately so the one below is given\\n' + '#in case the reproduced version is not \"correct\".\\n';\n    rstatsCode += '# ' + requestLineWithOriginalUrl;\n  }\n\n  return rstatsCode + '\\n';\n};\n\nmodule.exports = torstats;","map":{"version":3,"sources":["/home/saurabh/Desktop/saarthi/frontend/node_modules/curlconverter/generators/r.js"],"names":["util","require","jsesc","querystring","reprn","value","repr","quotes","getQueryDict","request","queryDict","Object","keys","query","map","paramName","rawValue","paramValue","Array","isArray","join","getDataString","data","toString","isDataRaw","startsWith","filePath","slice","parsedQueryString","parse","sort","keyCount","length","singleKeyOnly","singularData","isDataBinary","getMultipleDataString","repeatedKey","key","dataString","els","i","push","getFilesString","filesString","multipartUploads","multipartKey","multipartValue","fileParam","fileName","torstats","curlCommand","parseCurlCommand","cookieDict","cookies","cookieName","headerDict","headers","hels","headerName","url","match","urlWithoutQuery","requestLineWithUrlParams","method","toUpperCase","requestLineWithOriginalUrl","requestLineBody","insecure","auth","splitAuth","split","user","password","replace","rstatsCode","module","exports"],"mappings":"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","sourcesContent":["// Author: Bob Rudis (bob@rud.is)\n\nconst util = require('../util')\nconst jsesc = require('jsesc')\nconst querystring = require('query-string')\n\nrequire('string.prototype.startswith')\n\nfunction reprn (value) { // back-tick quote names\n  if (!value) {\n    return '``'\n  } else {\n    return '`' + value + '`'\n  }\n}\n\nfunction repr (value) {\n  // In context of url parameters, don't accept nulls and such.\n  if (!value) {\n    return \"''\"\n  } else {\n    return \"'\" + jsesc(value, { quotes: 'single' }) + \"'\"\n  }\n}\n\nfunction getQueryDict (request) {\n  let queryDict = 'params = list(\\n'\n  queryDict += Object.keys(request.query).map((paramName) => {\n    const rawValue = request.query[paramName]\n    let paramValue\n    if (Array.isArray(rawValue)) {\n      paramValue = 'c(' + rawValue.map(repr).join(', ') + ')'\n    } else {\n      paramValue = repr(rawValue)\n    }\n    return ('  ' + reprn(paramName) + ' = ' + paramValue)\n  }).join(',\\n')\n  queryDict += '\\n)\\n'\n  return queryDict\n}\n\nfunction getDataString (request) {\n  if (typeof request.data === 'number') {\n    request.data = request.data.toString()\n  }\n  if (!request.isDataRaw && request.data.startsWith('@')) {\n    const filePath = request.data.slice(1)\n    return 'data = upload_file(\\'' + filePath + '\\')'\n  }\n\n  const parsedQueryString = querystring.parse(request.data, { sort: false })\n  const keyCount = Object.keys(parsedQueryString).length\n  const singleKeyOnly = keyCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]]\n  const singularData = request.isDataBinary || singleKeyOnly\n  if (singularData) {\n    return 'data = ' + repr(request.data) + '\\n'\n  } else {\n    return getMultipleDataString(request, parsedQueryString)\n  }\n}\n\nfunction getMultipleDataString (request, parsedQueryString) {\n  let repeatedKey = false\n  for (const key in parsedQueryString) {\n    const value = parsedQueryString[key]\n    if (Array.isArray(value)) {\n      repeatedKey = true\n    }\n  }\n\n  let dataString\n  if (repeatedKey) {\n    const els = []\n    dataString = 'data = list(\\n'\n    for (const key in parsedQueryString) {\n      const value = parsedQueryString[key]\n      if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n          els.push('  ' + reprn(key) + ' = ' + repr(value[i]))\n        }\n      } else {\n        els.push('  ' + reprn(key) + ' = ' + repr(value))\n      }\n    }\n    dataString += els.join(',\\n')\n    dataString += '\\n)\\n'\n  } else {\n    dataString = 'data = list(\\n'\n    dataString += Object.keys(parsedQueryString).map((key) => {\n      const value = parsedQueryString[key]\n      return ('  ' + reprn(key) + ' = ' + repr(value))\n    }).join(',\\n')\n    dataString += '\\n)\\n'\n  }\n\n  return dataString\n}\n\nfunction getFilesString (request) {\n  // http://docs.rstats-requests.org/en/master/user/quickstart/#post-a-multipart-encoded-file\n  let filesString = 'files = list(\\n'\n  filesString += Object.keys(request.multipartUploads).map((multipartKey) => {\n    const multipartValue = request.multipartUploads[multipartKey]\n    let fileParam\n    if (multipartValue.startsWith('@')) {\n      const fileName = multipartValue.slice(1)\n      // filesString += '    ' + reprn(multipartKey) + ' (' + repr(fileName) + ', upload_file(' + repr(fileName) + '))'\n      fileParam = '  ' + reprn(multipartKey) + ' = upload_file(' + repr(fileName) + ')'\n    } else {\n      fileParam = '  ' + reprn(multipartKey) + ' = ' + repr(multipartValue) + ''\n    }\n    return (fileParam)\n  }).join(',\\n')\n  filesString += '\\n)\\n'\n\n  return filesString\n}\n\nconst torstats = curlCommand => {\n  const request = util.parseCurlCommand(curlCommand)\n  let cookieDict\n  if (request.cookies) {\n    cookieDict = 'cookies = c(\\n'\n    cookieDict += Object.keys(request.cookies).map(cookieName => '  ' + repr(cookieName) + ' = ' + repr(request.cookies[cookieName])).join(',\\n')\n    cookieDict += '\\n)\\n'\n  }\n  let headerDict\n  if (request.headers) {\n    const hels = []\n    headerDict = 'headers = c(\\n'\n    for (const headerName in request.headers) {\n      hels.push('  ' + reprn(headerName) + ' = ' + repr(request.headers[headerName]))\n    }\n    headerDict += hels.join(',\\n')\n    headerDict += '\\n)\\n'\n  }\n\n  let queryDict\n  if (request.query) {\n    queryDict = getQueryDict(request)\n  }\n\n  let dataString\n  let filesString\n  if (typeof request.data === 'string' || typeof request.data === 'number') {\n    dataString = getDataString(request)\n  } else if (request.multipartUploads) {\n    filesString = getFilesString(request)\n  }\n  // curl automatically prepends 'http' if the scheme is missing, but rstats fails and returns an error\n  // we tack it on here to mimic curl\n  if (!request.url.match(/https?:/)) {\n    request.url = 'http://' + request.url\n  }\n  if (!request.urlWithoutQuery.match(/https?:/)) {\n    request.urlWithoutQuery = 'http://' + request.urlWithoutQuery\n  }\n  let requestLineWithUrlParams = 'res <- httr::' + request.method.toUpperCase() + '(url = \\'' + request.urlWithoutQuery + '\\''\n  let requestLineWithOriginalUrl = 'res <- httr::' + request.method.toUpperCase() + '(url = \\'' + request.url + '\\''\n\n  let requestLineBody = ''\n  if (request.headers) {\n    requestLineBody += ', httr::add_headers(.headers=headers)'\n  }\n  if (request.query) {\n    requestLineBody += ', query = params'\n  }\n  if (request.cookies) {\n    requestLineBody += ', httr::set_cookies(.cookies = cookies)'\n  }\n  if (typeof request.data === 'string') {\n    requestLineBody += ', body = data'\n  } else if (request.multipartUploads) {\n    requestLineBody += ', body = files'\n  }\n  if (request.insecure) {\n    requestLineBody += ', config = httr::config(ssl_verifypeer = FALSE)'\n  }\n  if (request.auth) {\n    const splitAuth = request.auth.split(':')\n    const user = splitAuth[0] || ''\n    const password = splitAuth[1] || ''\n    requestLineBody += ', httr::authenticate(' + repr(user) + ', ' + repr(password) + ')'\n  }\n  requestLineBody += ')'\n\n  requestLineWithOriginalUrl += requestLineBody.replace(', query = params', '')\n  requestLineWithUrlParams += requestLineBody\n\n  let rstatsCode = ''\n  rstatsCode += 'require(httr)\\n\\n'\n  if (cookieDict) {\n    rstatsCode += cookieDict + '\\n'\n  }\n  if (headerDict) {\n    rstatsCode += headerDict + '\\n'\n  }\n  if (queryDict) {\n    rstatsCode += queryDict + '\\n'\n  }\n  if (dataString) {\n    rstatsCode += dataString + '\\n'\n  } else if (filesString) {\n    rstatsCode += filesString + '\\n'\n  }\n  rstatsCode += requestLineWithUrlParams\n\n  if (request.query) {\n    rstatsCode += '\\n\\n' +\n            '#NB. Original query string below. It seems impossible to parse and\\n' +\n            '#reproduce query strings 100% accurately so the one below is given\\n' +\n            '#in case the reproduced version is not \"correct\".\\n'\n    rstatsCode += '# ' + requestLineWithOriginalUrl\n  }\n\n  return rstatsCode + '\\n'\n}\n\nmodule.exports = torstats\n"]},"metadata":{},"sourceType":"script"}