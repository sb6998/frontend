{"ast":null,"code":"import { argsert } from './argsert.js';\nimport { assertNotStrictEqual } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, shim) {\n  const __ = shim.y18n.__;\n  const __n = shim.y18n.__n;\n  const self = {};\n\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands();\n    const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n\n    const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString()) : null);\n        } else {\n          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString()) : null);\n        } else {\n          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n        }\n      }\n    }\n  };\n\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n    }\n  };\n\n  self.requiredArguments = function requiredArguments(argv, demandedOptions) {\n    let missing = null;\n\n    for (const key of Object.keys(demandedOptions)) {\n      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    }\n\n    if (missing) {\n      const customMsgs = [];\n\n      for (const key of Object.keys(missing)) {\n        const msg = missing[key];\n\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      }\n\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  };\n\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n    let checkPositionals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n    var _a;\n\n    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getInternalMethods().getContext();\n    Object.keys(argv).forEach(key => {\n      if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n        unknown.push(key);\n      }\n    });\n\n    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (!commandKeys.includes('' + key)) {\n          unknown.push('' + key);\n        }\n      });\n    }\n\n    if (checkPositionals) {\n      const demandedCommands = yargs.getDemandedCommands();\n      const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;\n      const expected = currentContext.commands.length + maxNonOptDemanded;\n\n      if (expected < argv._.length) {\n        argv._.slice(expected).forEach(key => {\n          key = String(key);\n\n          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {\n            unknown.push(key);\n          }\n        });\n      }\n    }\n\n    if (unknown.length) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  };\n\n  self.unknownCommands = function unknownCommands(argv) {\n    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getInternalMethods().getContext();\n\n    if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (!commandKeys.includes('' + key)) {\n          unknown.push('' + key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n      return false;\n    }\n\n    const newAliases = yargs.parsed.newAliases;\n    return [key, ...aliases[key]].some(a => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);\n  };\n\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {\n        [].concat(argv[key]).forEach(value => {\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n\n    let msg = __('Invalid values:');\n\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  };\n\n  let implied = {};\n\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        assertNotStrictEqual(value, undefined, shim);\n        implied[key].push(value);\n      }\n    }\n  };\n\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n\n  function keyExists(argv, val) {\n    const num = Number(val);\n    val = isNaN(num) ? val : num;\n\n    if (typeof val === 'number') {\n      val = argv._.length >= val;\n    } else if (val.match(/^--no-.+/)) {\n      val = val.match(/^--no-(.+)/)[1];\n      val = !Object.prototype.hasOwnProperty.call(argv, val);\n    } else {\n      val = Object.prototype.hasOwnProperty.call(argv, val);\n    }\n\n    return val;\n  }\n\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let key = origKey;\n        const origValue = value;\n        key = keyExists(argv, key);\n        value = keyExists(argv, value);\n\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n\n  let conflicting = {};\n\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n\n  self.getConflicting = () => conflicting;\n\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n\n    if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {\n      Object.keys(conflicting).forEach(key => {\n        conflicting[key].forEach(value => {\n          if (value && argv[shim.Parser.camelCase(key)] !== undefined && argv[shim.Parser.camelCase(value)] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      });\n    }\n  };\n\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const threshold = 3;\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate);\n\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, k => !localLookup[k]);\n    conflicting = objFilter(conflicting, k => !localLookup[k]);\n    return self;\n  };\n\n  const frozens = [];\n\n  self.freeze = function freeze() {\n    frozens.push({\n      implied,\n      conflicting\n    });\n  };\n\n  self.unfreeze = function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      implied,\n      conflicting\n    } = frozen);\n  };\n\n  return self;\n}","map":{"version":3,"sources":["/home/saurabh/Desktop/saarthi/frontend/node_modules/@curlconverter/yargs/build/lib/validation.js"],"names":["argsert","assertNotStrictEqual","levenshtein","distance","objFilter","specialKeys","validation","yargs","usage","shim","__","y18n","__n","self","nonOptionCount","argv","demandedCommands","getDemandedCommands","positionalCount","_","length","_s","getInternalMethods","getContext","commands","min","max","minMsg","undefined","fail","replace","toString","maxMsg","required","observed","requiredArguments","demandedOptions","missing","key","Object","keys","prototype","hasOwnProperty","call","customMsgs","msg","indexOf","push","customMsg","join","unknownArguments","aliases","positionalMap","isDefaultCommand","checkPositionals","_a","commandKeys","getCommandInstance","getCommands","unknown","currentContext","forEach","includes","getParseContext","isValidAndSomeAliasIsNotNew","slice","maxNonOptDemanded","expected","String","unknownCommands","newAliases","parsed","some","a","limitedChoices","options","getOptions","invalid","choices","concat","value","invalidKeys","stringifiedValues","implied","implies","arguments","k","global","Array","isArray","i","getImplied","keyExists","val","num","Number","isNaN","match","implications","implyFail","origKey","origValue","conflicting","conflicts","getConflicting","conflictingFn","getParserConfiguration","Parser","camelCase","recommendCommands","cmd","potentialCommands","threshold","sort","b","recommended","bestDistance","Infinity","candidate","d","reset","localLookup","frozens","freeze","unfreeze","frozen","pop"],"mappings":"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","sourcesContent":["import { argsert } from './argsert.js';\nimport { assertNotStrictEqual, } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, shim) {\n    const __ = shim.y18n.__;\n    const __n = shim.y18n.__n;\n    const self = {};\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n        const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;\n        if (demandedCommands._ &&\n            (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n                }\n            }\n        }\n    };\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n        }\n    };\n    self.requiredArguments = function requiredArguments(argv, demandedOptions) {\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) ||\n                typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {\n        var _a;\n        const commandKeys = yargs\n            .getInternalMethods()\n            .getCommandInstance()\n            .getCommands();\n        const unknown = [];\n        const currentContext = yargs.getInternalMethods().getContext();\n        Object.keys(argv).forEach(key => {\n            if (!specialKeys.includes(key) &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if (checkPositionals &&\n            (currentContext.commands.length > 0 ||\n                commandKeys.length > 0 ||\n                isDefaultCommand)) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (!commandKeys.includes('' + key)) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (checkPositionals) {\n            const demandedCommands = yargs.getDemandedCommands();\n            const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;\n            const expected = currentContext.commands.length + maxNonOptDemanded;\n            if (expected < argv._.length) {\n                argv._.slice(expected).forEach(key => {\n                    key = String(key);\n                    if (!currentContext.commands.includes(key) &&\n                        !unknown.includes(key)) {\n                        unknown.push(key);\n                    }\n                });\n            }\n        }\n        if (unknown.length) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs\n            .getInternalMethods()\n            .getCommandInstance()\n            .getCommands();\n        const unknown = [];\n        const currentContext = yargs.getInternalMethods().getContext();\n        if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (!commandKeys.includes('' + key)) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        return [key, ...aliases[key]].some(a => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);\n    };\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach(value => {\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach(key => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.implies(key, i));\n            }\n            else {\n                assertNotStrictEqual(value, undefined, shim);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            val = val.match(/^--no-(.+)/)[1];\n            val = !Object.prototype.hasOwnProperty.call(argv, val);\n        }\n        else {\n            val = Object.prototype.hasOwnProperty.call(argv, val);\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach(key => {\n            const origKey = key;\n            (implied[key] || []).forEach(value => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach(value => {\n                msg += value;\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach(key => {\n            if (conflicting[key]) {\n                conflicting[key].forEach(value => {\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n        if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {\n            Object.keys(conflicting).forEach(key => {\n                conflicting[key].forEach(value => {\n                    if (value &&\n                        argv[shim.Parser.camelCase(key)] !== undefined &&\n                        argv[shim.Parser.camelCase(value)] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            });\n        }\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3;\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = distance(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = objFilter(implied, k => !localLookup[k]);\n        conflicting = objFilter(conflicting, k => !localLookup[k]);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            conflicting,\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({ implied, conflicting } = frozen);\n    };\n    return self;\n}\n"]},"metadata":{},"sourceType":"module"}